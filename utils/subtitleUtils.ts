import { CaptionPreset } from '@/components/edit/EditSection';

interface Word {
  word: string;
  start: number;
  end: number;
}

interface Segment {
  id: number;
  start: number;
  end: number;
  text: string;
  words: Word[];
}

interface WordTimestamps {
  text: string;
  segments: Segment[];
}

// Convert hex color to ASS format (AABBGGRR)
function convertHexToASSColor(hex: string, opacity = 1): string {
  // Remove # if present
  hex = hex.replace('#', '');
  
  // Parse RGB components
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  
  // Calculate alpha (00 = opaque, FF = transparent in ASS)
  const alpha = Math.round((1 - opacity) * 255)
    .toString(16)
    .padStart(2, '0')
    .toUpperCase();
  
  // Return in ASS format
  return `&H${alpha}${b.toString(16).padStart(2, '0').toUpperCase()}${g.toString(16).padStart(2, '0').toUpperCase()}${r.toString(16).padStart(2, '0').toUpperCase()}`;
}

// Format time (seconds) to ASS format (h:mm:ss.cc)
function formatAssTime(seconds: number): string {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  const cs = Math.floor((seconds % 1) * 100);
  
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
}

// Get alignment value for ASS (1-9 numpad style)
function getAssAlignment(position: string, alignment?: string): number {
  // Always use center position (4, 5, 6) as base
  let baseValue = 4; // center vertical position
  
  let offset = 1; // center alignment
  if (alignment === 'left') offset = 0;
  else if (alignment === 'right') offset = 2;
  
  return baseValue + offset;
}

// Calculate vertical position based on marginY (-100 to 100)
function calculateVerticalPosition(marginY: number): number {
  // Convert marginY (-100 to 100) to a value between 0 and 720 (video height)
  // Center position is at 360
  // marginY of -100 should be near top (around 60)
  // marginY of 100 should be near bottom (around 660)
  
  const center = 360;
  const maxOffset = 300; // Maximum distance from center
  
  return center + (marginY / 100) * maxOffset;
}

// Generate ASS subtitle file
export function generateASS(wordTimestamps: WordTimestamps, preset: CaptionPreset): string {
  // Extract font name from font family
  const fontName = preset.fontFamily.split(',')[0].trim();
  
  // Get colors in ASS format
  const primaryColor = convertHexToASSColor(preset.textColor || preset.color);
  const secondaryColor = convertHexToASSColor(preset.highlightColor || '#FFFF00');  // Use preset highlight color
  const outlineColor = convertHexToASSColor(preset.outlineColor || '#000000');
  const bgColor = preset.backgroundColor ? 
    convertHexToASSColor(preset.backgroundColor, preset.bgOpacity || 0) : 
    '&H00000000';
  
  // Get alignment - always use center position as base with proper vertical alignment
  // If marginY is positive (toward bottom), use alignment 2 (bottom center)
  // If marginY is negative (toward top), use alignment 8 (top center) 
  // If marginY is 0, use alignment 5 (middle center)
  let alignmentValue;
  if (preset.marginY > 50) {
    alignmentValue = 2; // Bottom center
  } else if (preset.marginY < -50) {
    alignmentValue = 8; // Top center
  } else {
    alignmentValue = 5; // Middle center
  }
  
  // Calculate vertical position based on marginY
  const verticalPosition = calculateVerticalPosition(preset.marginY || 0);
  
  // Get font weight
  const bold = preset.fontWeight === 'bold' ? '1' : '0';
  
  // Get outline and shadow settings
  const outline = preset.textOutline ? '2' : '1';
  const shadow = preset.textShadow ? '1' : '0';
  
  // Default font size - use preset fontSize directly
  // ASS subtitle font sizes are already scaled for 1280x720 video
  const fontSize = preset.fontSize || 24;

  // Start building ASS file
  let assContent = `[Script Info]
; Script generated by TROD
ScriptType: v4.00+
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${fontName},${fontSize},${primaryColor},${secondaryColor},${outlineColor},${bgColor},${bold},0,0,0,100,100,0,0,1,${outline},${shadow},${alignmentValue},10,10,${Math.abs(preset.marginY || 0)},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  // Process segments and words
  if (wordTimestamps?.segments) {
    // Get the effective words per line from preset
    const wordsPerLine = preset.wordsPerLine || 4;
    
    // Process each segment
    wordTimestamps.segments.forEach(segment => {
      const words = segment.words;
      
      // Group words by wordsPerLine
      for (let i = 0; i < words.length; i += wordsPerLine) {
        const wordChunk = words.slice(i, i + wordsPerLine);
        if (wordChunk.length === 0) continue;
        
        // Get the time range for this chunk of words
        const chunkStartTime = formatAssTime(wordChunk[0].start);
        const chunkEndTime = formatAssTime(wordChunk[wordChunk.length - 1].end);
        
        // For each word in the chunk, create a dialogue entry for its time period
        // with appropriate highlighting
        wordChunk.forEach((word, index) => {
          const startTime = formatAssTime(word.start);
          const endTime = formatAssTime(word.end);
          
          // Create the text with the current word highlighted
          // We'll use ASS tags to format each word
          let lineText = "";
          
          // We need to handle word highlighting
          // Use ASS tags to format each word
          wordChunk.forEach((w, idx) => {
            // Add a space before words (except first)
            if (idx > 0) lineText += " ";
            
            // Add ASS formatting for highlighting current word
            if (idx === index) {
              // Current word - highlight it with animation if enabled
              if (preset.animation === 'highlight' || preset.animation === 'fade') {
                // Use the highlight color for the word
                lineText += `{\\c${secondaryColor}`;
                
                // Add animation effect if specified
                if (preset.animation === 'fade') {
                  // Fading effect simulation with ASS
                  lineText += `\\alpha&H40\\t(0,250,\\alpha&H00)\\t(250,500,\\alpha&H40)`;
                }
                
                // Increase size slightly for emphasis
                lineText += `\\fscx110\\fscy110}${w.word}{\\r}`;
              } else if (preset.animation === 'slide') {
                // Sliding/bouncing animation
                lineText += `{\\c${secondaryColor}\\fscx110\\fscy110`;
                lineText += `\\t(0,250,\\frz-1)\\t(250,500,\\frz1)}${w.word}{\\r}`;
              } else {
                // Default highlight without animation
                lineText += `{\\c${secondaryColor}\\fscx110\\fscy110}${w.word}{\\r}`;
              }
            } else {
              // Regular word - no special formatting
              lineText += w.word;
            }
          });
          
          // Add the dialogue line - apply position explicitly in each dialogue line
          let finalText = lineText;
          if (preset.backgroundColor && preset.bgOpacity > 0) {
            // Add background box with proper color - use calculated vertical position
            finalText = `{\\bord0\\shad0\\3c&H000000&\\3a&H00&${preset.bgOpacity > 0 ? `\\4c${bgColor}\\4a&H00&` : ''}\\pos(640,${verticalPosition})\\p1}m 0 0 l 1000 0 1000 60 0 60{\\p0}\\N${lineText}`;
          } else if (preset.marginY !== 0) {
            // If no background but marginY is set, add position override
            finalText = `{\\pos(640,${verticalPosition})}${lineText}`;
          }
          
          // Add the dialogue line
          assContent += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${finalText}\n`;
        });
      }
    });
  }
  
  return assContent;
} 